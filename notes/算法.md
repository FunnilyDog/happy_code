# 给定一个数组，和一个目标值， 寻找数组中 最接近目标值 的 两数之和 返回两数下标

```typescript
const findNum = (nums: number[], target: number) => {
  const len = nums.length;
  let resultSum = Infinity;
  let resL = [];
  for (let l = 0; l < len; l++) {
    for (let r = len - 1; r > l; r--) {
      const sum = nums[l] + nums[r];
      if (sum === target) return [l, r];
      const res = Math.min(
        Math.abs(sum - target),
        Math.abs(resultSum - target)
      );
      if (res === Math.abs(sum - target)) {
        resL = [l, r];
        resultSum = sum;
      }
    }
  }
  return resL;
};
```

# 合并两个有序链表

```ts
const mergeListNode = (head, head2) => {
  let l = head,
    r = head2,
    resNode = null;
  const fn = (node) => {
    if (!resNode) resNode = node;
    else resNode.next = node;
  };
  while (l !== null && r !== null) {
    if (l.value < r.value) {
      fn(l);
      l = l.next;
    } else {
      fn(r);
      r = r.next;
    }
  }
  if (l) resNode.next = l;
  if (r) resNode.next = r;
  return resNode;
};
```

# 链表反转

```ts
// 反转链表

type ListNode = {
  value: number;
  next: ListNode | null;
};

const ndoe = {
  value: 2,
  next: {
    value: 3,
    next: null
  }
};
function reverseList(head: ListNode | null): ListNode | null {
  let pre = null,
    cur = head;
  while (cur) {
    const next = cur.next;
    cur.next = pre;
    pre = cur;
    cur = next;
  }
  return pre;
}
reverseList(ndoe);
```

# 数组快排

```ts
// 递归
function quickSort(arr: number[]): number[] {
  if (arr.length <= 1) {
    return arr;
  }
  const pivot = arr[0];
  const left = [];
  const right = [];
  for (let i = 1; i < arr.length; i++) {
    if (arr[i] < pivot) {
      left.push(arr[i]);
    } else if (arr[i] > pivot) {
      right.push(arr[i]);
    }
  }
  return quickSort(left).concat(pivot, quickSort(right));
}

// 非递归快排
function quickSort2(nums: number[]): number[] {
  // 递归栈
  const stack: Array<number[]> = [];
  stack.push(nums);
  let res: number[] = [];
  while (stack.length) {
    const arr = stack.pop() as number[];
    if (arr.length <= 1) {
      if (arr.length) res.unshift(arr[0]);
      continue;
    }
    const len = arr.length;
    // 二分排序
    let left = [],
      right = [],
      cur = arr[0];
    for (let i = 1; i < len; i++) {
      if (arr[i] > cur) right.push(arr[i]);
      else left.push(arr[i]);
    }
    stack.push(left, [cur], right);
  }
  return res;
}

// 选择排序
// 找出未排序段中的最小值 放在排好序的末尾
function quickSort3(nums: number[]): number[] {
  let res = [];
  const len = nums.length;
  for (let i = 0; i < len; i++) {
    let minIdx = i;
    for (let m = i + 1; m < len; m++) {
      if (nums[m] < nums[minIdx]) minIdx = m;
    }
    res.push(nums[minIdx]);
  }
  return res;
}

// 冒泡排序
/**
 * 从无序序列头部开始，进行两两比较，根据大小交换位置，
 * 直到最后将最大（小）的数据元素交换到了无序队列的队尾，
 * 从而成为有序序列的一部分；下一次继续这个过程，
 * 直到所有数据元素都排好序。
 */
function quickSort4(nums: number[]): number[] {
  const len = nums.length;
  for (let i = 0; i < len; i++) {
    for (let m = 0; m < len - i - 1; m++) {
      if (arr[m] > arr[m + 1]) {
        [arr[m], arr[m + 1]] = [arr[m + 1], arr[m]];
      }
    }
  }
  return nums;
}

// 插入排序
// 假设前面 n-1 的元素已经排好序，将第n个元素插入到前面已经排好的序列中。
function quickSort5(nums: number[]) {
  const len = nums.length;
  for (let i = 0; i < len - 1; i++) {
    let cur = i,
      // 下一个需要插入的元素
      next = i + 1;
    while (cur >= 0) {
      if (nums[next] < nums[cur]) cur--;
      else break;
    }
    if (next !== cur + 1) {
      const del = nums.splice(next, 1);
      nums.splice(cur + 1, 0, del[0]);
    }
  }
  return nums;
}
```

# 最大面积

```ts
function maxArea3(height: number[]): number {
  const len = height.length;
  let area = 0,
    left = 0,
    right = len - 1;
  while (left < right) {
    let cur, newArea;

    if (height[left] < height[right]) {
      cur = height[left];
      newArea = cur * (right - left);
      while (height[left] <= cur && left < right) {
        left++;
      }
    } else {
      cur = height[right];
      newArea = cur * (right - left);
      while (height[right] <= cur && left < right) {
        right--;
      }
    }
    area = Math.max(area, newArea);
  }
  return area;
}
```

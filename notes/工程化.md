# pnpm npm yarn

pnpm 通过硬链接、冗余移除、压缩存储、并行安装和锁定文件等机制，实现了高效、可共享的依赖管理方式，有效地减少了磁盘空间占用和重复下载的问题，并提高了安装速度

pnpm 使用符号链接 Symbolic link（软链接）来创建依赖项的嵌套结构，将项目的直接依赖符号链接到 node_modules 的根目录，
直接依赖的实际位置在.pnpm/<name>@<version>/node_modules/<name>，
依赖包中的每个文件再硬链接（Hard link）到.pnpm store

npm yarn 会在每个 node_modules 目录为所有依赖项村粗完整文件副本，如果有相同依赖 则会被重复存储。
采用扁平依赖树来管理依赖包，解决依赖嵌套层级过深 以及重复安装 问题

# apply call bind

```javascript
fn.apply(thisObj, [1, 2, 3]);
fn.call(thisObj, 1, 2, 3);
const a = fn.bind(thisObj, 1, 2, 3);
a();
```

# Commonjs(node) 和 es nodule 模块化 导入导出的区别

## CommonJs

    关键字：导入 require 导出 module.exports / exports
    可以导出任意类型，为同步加载模块 因此不适用于浏览器（若某个模块加载很慢会导致页面假死）。
    CommonJs如何避免循环导入：
    首先加载之后的文件的 module 会被缓存到 Module 上，比如一个模块已经 require 引入了 a 模块，如果另外一个模块再次引用 a ，那么会直接读取缓存值 module ，所以无需再次执行模块
    module.exports / exports 区别：
    如果我们不想在 commonjs 中导出对象，而是只导出一个类或者一个函数再或者其他属性的情况，那么 module.exports 就更方便
    exports 会被初始化成一个对象，也就是我们只能在对象上绑定属性

## ES Module

    关键字: 导入 import 导出 export / export defult
    ES6 module 的引入和导出是静态的,可导出任意类型，可默认导出某个属性，导入导出时可用 as 关键字 重命名 导入导出属性。也可用于node 模块化

    ES Module 避免循环依赖：
    ES Module借助模块地图，已经进入过的模块标注为获取中，遇到import语句会去检查这个地图，已经标注为获取中的则不会进入，地图中的每一个节点是一个模块记录，上面有导出变量的内存地址，导入时会做一个连接——即指向同一块内存。

    import() 动态引入:
    import() 返回一个 Promise 对象， 返回的 Promise 的 then 成功回调中，可以获取模块的加载成功信息。

# 浏览器内核

## 渲染引擎

    解析HTML、CSS

    Trident: IE浏览器、百度浏览器
    Gecko: Firefox浏览器
    Blink: Opera浏览器、Chrome浏览器、Edge浏览器
    Webkit: Safari浏览器

    解决渲染引擎引起的兼容问题：Normalize.css

## JS 引擎

    常见引擎及所在浏览器
    Chakra:微软开发，用于IE浏览器
    JavaScriptCore:WebKit中的JavaScript引擎，Apple公司开发
    V8:Google开发的强大JavaScript引擎，也帮助Chrome从众多浏览器中脱颖而出

    v8引擎执行过程：
    进行Parser (词法分析，语法分析)成抽象 AST 树
    AST 通过 Ignition（理解成解释器或者转化器）生成 bytecode(字节码)，js 实现跨平台的关键点
    最后根据运行环境，自动将字节码转成对应的汇编代码->机器码，由 CPU 执行

# 垃圾回收机制

## 浏览器垃圾回收机制

引用计数:
跟踪记录每个引用类型被使用的次数，赋值+1，变更-1，当引用计数为 0 时被回收

弊端：循环引用将不可被清除、需要开辟新内存存储引用计数

标记清除：
为程序中所有的变量添加上一个二进制字符(二进制运算最快)并初始值置为 0(默认全是垃圾)，然后遍历所有的对象，被使用的变量标记置为 1，所有被标记置为 1 的变量所引用的变量也置为 1，在程序运行结束时回收掉所有标记为零的变量，回收结束之后将现存变量标记统一置为 0，等待下一轮回收开启。

弊端：耗时，产生内存碎片

## V8 垃圾回收优化

### 分代式

V8 将内存空间划分为 新生代 和 老生代
. 新生代存储新产生的(存活时间较短)较小的对象，其内存空间通常只有 1 ～ 8M
. 新生代会被拆分为使用区和空闲区，新的对象都会被分配到使用区，当使用区快满时则进行新生代区域的垃圾回收：
对使用区的活动对象进行标记，标记完成后将活跃对象复制到空闲区并排序，随后对使用区进行清理，最后将使用区与空闲区对换。

· 当一个对象被多次复制还未被清理掉，故此对象会被认定为生命周期较长的对象，会被从新生代移动到老生代中
· 老生代存储着较大或生命周期较长的对象，对老生代垃圾回收则使用标记整理算法

### 优化

-- V8 在垃圾回收时会同时开启多个辅助线程进行并行回收
-- V8 会在标记阶段采用三色标记法进行切片处理（标记开始时所有对象都为白色，从跟对象开始将可达位置标记为灰色，若中断标记，后续直接从灰色继续开始同时将灰色置为黑色同时将下一代对象置为灰色，直至无可标记为灰色对象为止便 开始清除），为保障切片过程中已标记过的对象产生的新对象未被标记，会强制判断一旦有黑色的对象引用白色的对象，就会强制将被引用的白色变量标记为灰色。

-- V8 标记完成后，如果内存足够便不会立即进行清理。

# MVVM MVC MVP

## MVC

    . Model: 主要管理业务模型的数据和行为，它既保存程序的数据，也定义了处理该数据的逻辑
    . View: 接收用户的交互请求并展示数据信息给用户
    . Controller: View 接收到用户的交互请求之后，会将请求转发给 Controller，
      Controller 解析用户的请求之后，就会交给对应的 Model 去处理

## MVP

    三件套各自的职责和依赖关系和变种 MVC 里的职责和依赖关系其实是一样的，
    但不同的是，MVP 之间的交互主要是通过接口实现的，Model、View、Presenter
    都有各自的接口，降低模块之间的耦合性，便于进行单元测试了，维护性和扩展性也提高了。
    但是 需要编写的代码量变多，需要对业务模块之前的交互抽象成借口定义，对开发的设计能力要求高。

## MVVM

    MVVM 最重要的一个特性就是数据绑定，通过将 View 的属性绑定到 ViewModel，
    可以使两者之间松耦合，也完全不需要在 ViewModel 里写代码去直接更新一个 View

    . ViewModel: 视图模型，封装的是视图的表示逻辑和数据，
      是对视图的抽象，包括视图的属性和命令，或视图的状态和行为。

总结: MVP 和 MVVM 都是为了解决界面和数据的分离问题，两者只是采用了不同的实现方案。
MVP 之间的交互主要是通过接口实现的，其主要弊端就是需要编写大量接口。
MVVM 则是通过数据绑定的方式实现交互，虽然其实现需要依赖具体的一些框架工具，
但明显大大减少了开发者需要编写的代码量。

# Tree Shakig

    利用es module 静态引用的特性，在打包时从entry入口出发扫描所有依赖形成抽象语法树，随后运行所有代码，并打标，最后将没有被用到的代码消除掉。

# jwt 实现 登录 tooken

jwt(JSON Web Token) 是一种开放标准，用于在各方之间安全传输信息。主要用于身份验证和授权。

## JWT 组成： 头部、负载、签名三部分，之间用.分割。

    头部：主要描述 JWT 的元数据，包括令牌类型，加密算法等。
    负载：数据声明部分，主要包含用户或其他实体信息，如 用户 id，用户名等。有 3 种声明类型：注册声明（JWT 规范中预定义的声明），公共声明（用户自定义的声明），私有声明（使用 JWT 的双方共享的自定义声明）
    签名：签名是用于验证消息在传递过程中没有被篡改。它是通过头部中指定的签名算法，对编码后的头部和编码后的负载进行签名计算得到的

## JWT 登录鉴权

    用户输入账号密码信息
    服务器验证信息是否正确，返回已签名token（JWT）
    将token存储在客户端（local storage）/ cookie
    在之后的HTTP请求中将token添加到请求头（一般为Authorazation）
    服务器解码JWT，有效则接受请求。

#
